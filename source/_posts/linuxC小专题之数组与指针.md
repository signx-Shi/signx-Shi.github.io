---
title: linuxC  数组与指针专题
date: 2018-04-09 15:35:49
tags:
---

## 数组与指针的概念解析

前几天,有同学跟我向我询问指针与数组的问题,当时我是拒绝的,因为我怕误人子弟,但是当我把我当年的经验和方法跟他简单说了一下后,竟然收获奇效,故而产生了发这个贴子的念头,目的是为 了帮助那么仍在 泥潭 中的朋友们减轻一点点痛苦,当人本人技术所限,说的不对的,还请批评指正!
数组:
> 数组是在程序设计中，为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来的一种形式。这些按序排列的同类数据元素的集合称为**数组**。

指针:
> 计算机科学中，**指针**（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。

这些解释未免太官方,可惜某才疏学浅,也不乏自己组织语言将这两个概念解释清楚,各位权且一看,个中玄机,且听某一一道来.

## 小华的疑惑

小华:老师,关于数组和指针,我总是弄混淆,有没有简单容易的办法来区分呢.
张:这个问题你还来问我,**程序来源于生活,服务生活的嘛,遇到难点就要联系生活实际找比对啊**,现在你就可以拿你自己的生活经历来比对一下.
小华:老师你讲明白一点吧,这是要急死我啊!(ps:还是个急性子)
张:这样吧,我来问你 你家门牌号是多少号
小华:我家门牌号0号,小刚家是1号,小芳家 ,是2号,每次去小芳家小刚总知道,烦死他了
张:这样啊,据我所知你家里距县城是1000米,那你能告诉我小刚家,和小芳家都距县城多少米吗
小华:这简单啊,我们每家房子都是100米,小刚家就是1100米,小芳家就是1200米嘛
张:哈哈,你真聪明(PS:老师你是猴子请来的逗比吗??).现在比方我要去你家家访,你给我指路,你指一指
小华:(~吓,这样可不能让他轻易找到),我家在我们三家是门牌号是0号的,
张:这样我可找不到哦,我按地图找可看不到门牌号哟
小华:那我家在1000m处,怎么样
张:这好办啊,那如果我要去小芳家呢
小华,小芳家在1200米处
张:你不觉得这样说比较费事吗,比如你可以说,小芳在你家往后两家,或者说小芳家门牌号是2,
小华若有所思,好像明白了,**那么 请问你明白了吗**?

现在我们梳理一下,比如有i数组 家[3]={小华,小刚,小芳};  int aa[3]={华,小刚,小芳};
现在,程序初始化的时候将家这个数组初始化在 1000 这个位置,现在老师来了,老师要找到小芳家,老师首先要怎么做?
对了 ,老师首先要找到1000,即 p= aa;而小芳家在小华家往后两家,aa[0+2];但是在老师这里,老师要向前走两家,即 p+2;
那么老师走了多少米呢,答案是`1000+2*(100)`;所以我们知道小芳家在1200m处,**这个1200 叫做,内存地址**,aa[3] 里的**3 是数组内数据的个数**,
那么这个p.叫做指针,默认地,我们将p指向数组名**是为了获得数组首地址**,简单来说是为了帮P找到*归属感*,(简单提一下,C语言里面操作 *空指针* 是非法的,会导致 **SegmentionFault** 在WIN 下表现为*程序崩溃*),
>p指针的++ -- 等操作全部基于数组**在内存上的表现为 *连续不断的存储区域* **,如何理解**连续**呢,即 意思给你一组数据中的一个数据的内存,你可以*100%确定*这段内存后面的数据.
## 怎么灵活使用指针
初学C语言的时候,觉得那些会用指针的简直就是神,一个指针,在一段函数中 指来指去 ,就是不出错,可真是羡慕我等菜鸟啊,那么本来现在就来教大家用指针飞起
请看下题:
```C++
#include 
#include 

void reserve(char *head,char *tail,int size)
{
char *p=head;
char *q=tail;//声明指针的时候要赋值,避免野指针
printf("转换中head:%p,tail:%p,size:%d \n",head,tail,size);//%p代表打印地址变量

if(p >= q || size <= 0)//想一想这个条件还可以怎样写?  --->问题3?
return;
else
{
char temp=*p;
*p=*q;
*q= temp;
reserve(p+1,q-1,size-2);//递归调用
}


}

int main(int argc,const char *argv[] )
{
printf(" 本程序实现字符数组的反转效果:\n");
printf("请输入一句话:\n");

char string[128]={0};
scanf("%s",string);//注意此处未作越界处理  
printf("你输入的是:%s \n",string);

int size = strlen(string);

char *tail = &(string[size-1]);//想想为何要把 size-1    --->问题1?
reserve(string,tail,size);//想一想如果时两个参数 或者一个参数 函数该怎么写 --->问题2?

printf("反转之后为:%s \n",string);

return 0;
}
```
这道题属于基础题,目的在于让大家理解**指针与数组之间精妙的关系**,其实这道题远可以不这么麻烦,咱们就拿本题开刀
在题中我给大家提了几个问题,现在请大家思考几分钟?
1.首先 ,`char *tail = &(string[size-1]);`,这个变量完全可以省去,我可以直接用 `string+strlen(string)-1` ,那么即
`&(string[size-1]) == string+strlen(string)-1`,
那么此处为何要将size-1呢?
其实原因很明了,strlen返回的是数组的实际长度,即'\0'之前的数据个数,比如数组"123",返回3,但是string[size]表示什么呢,表示string[0+size],众所周知,数组的小标只能表示到总长-1,比如"123",长度为**4**,strlen为3,而string[3]即为第4个数据'\0',故而,要将size-1,那么举一反三,**想一想**,如果不-1 又会出现何种结果呢,**综上所述,string[size]='\0';代表字符数组的结尾,而我们程序实现的是字符串的反转,那么,如果不-1,理所当然 '\0'就会跑到数组的第一位.即string[0]位,这时候你用"%s" 格式化输出就已经不能够输出正确的数据了**?(想一想这是什么道理?,*提示:从 strlen 和 %s 的原理分析*)
2.其实大家仔细想一想,在1问中我说过,tail和`string+strlen(string)-1`,而size 就是strlen(string),那么这个函数 即是只有任意两个参数, 也能得到正确结果,因为任意某一个参数都能从别的两个参数计算而来,下面给大家一个两个参数版本:
```
void reserve2(char *head,char *tail)
{
char *p=head;
char *q=tail;//声明指针的时候要赋值,避免野指针
printf("转换中head:%p,tail:%p\n",head,tail);//%p代表打印地址变量

if(p >= q)
return;
else
{
char temp=*p;
*p=*q;
*q= temp;
reserve2(p+1,q-1);//递归调用
}
}
```
那么请大家思考一下如果是一个参数的情况,应该怎么写
3.其实这个两个条件是等价的 两种情况同时发生,因为**size= q-p+1**,解释这个问题等我把结果打印出来(**注:此结果为 gcc编译器所产生,不同编译器所产生的结果不同请自行辨别)
(1)
```
本程序实现字符数组的反转效果:
请输入一句话:
adc
你输入的是:adc 
转换中head:0xbfd87a2c,tail:0xbfd87a2e,size:3 
转换中head:0xbfd87a2d,tail:0xbfd87a2d,size:1 
反转之后为:cda 
```
(2)
```
 本程序实现字符数组的反转效果:
请输入一句话:
0123456789
你输入的是:0123456789 
转换中head:0xbfbb9dcc,tail:0xbfbb9dd5,size:10 
转换中head:0xbfbb9dcd,tail:0xbfbb9dd4,size:8 
转换中head:0xbfbb9dce,tail:0xbfbb9dd3,size:6 
转换中head:0xbfbb9dcf,tail:0xbfbb9dd2,size:4 
转换中head:0xbfbb9dd0,tail:0xbfbb9dd1,size:2 
转换中head:0xbfbb9dd1,tail:0xbfbb9dd0,size:0 
反转之后为:9876543210 
```
看这句`转换中head:0xbfbb9dcc,tail:0xbfbb9dd5,size:10 `,从~cc数到~d5 ,一共多少个数,其中我们知道~cc是string[0]的地址,那么~d5就是string[9]的地址,一共十个数,这也很好的解释了数组的最大的特点:*连续不断的存储区域*,所以我说这两个条件是等价的,同时发生的,所以只要写其中一个条件就行.
好了,三个问题解释完了,不知道你是否理解了这断代码所体现的指针的意义:**其实指针就是一个记录地址的数字,它本身的内容只是一串数字而已**,无论你是声明称char 还是int 类型的指针,它里面存的值永远是类似:`0xbfbb9dcc`这样的数,只不过,当声明 `int *p;`的时候,**系统会初始化 sizeof(int)个长度的字节**,当想取*p指向的数据的时候,又会自动找到从p开始的`sizeof(int)`个长度的字节,来把数"取出来",其实**指针并不创造数**,所以,当你明白了这个道理的时候,你就可以将**指针运用如飞了**.